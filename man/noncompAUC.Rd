% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/noncompAUC.R
\name{noncompAUC}
\alias{noncompAUC}
\title{Calculate the AUC using the trapezoidal rule}
\usage{
noncompAUC(
  DF,
  concentration = Concentration,
  time = Time,
  type = "LULD",
  extrap_inf = FALSE,
  extrap_inf_coefs = NULL,
  extrap_inf_times = c(NA, NA),
  reportFractExtrap = FALSE,
  extrap_t0 = FALSE,
  extrap_t0_coefs = NULL,
  extrap_t0_model = "monoexponential",
  extrap_t0_times = c(NA, NA),
  reportC0 = FALSE
)
}
\arguments{
\item{DF}{Input data.frame with concentration-time data.}

\item{concentration}{The name of the column containing drug concentrations}

\item{time}{The name of the column containing time data}

\item{type}{The type of trapezoidal rule to use. Options are "LULD" (default)
for "linear up, log down" or "linear".}

\item{extrap_inf}{Extrapolate the curve to infinity? TRUE or FALSE.}

\item{extrap_inf_coefs}{If you've already performed a nonlinear regression to
a monoexponential decay equation, \code{noncompAUC} will use that for
extrapolation to infinity. Provide a data.frame of the coefficients from a
\code{nls} regression. Format must be the standard output from
\code{summary(nls(...))[["coefficients"]]} or the coefficients from
\code{\link{elimFit}}. It doesn't matter what you name the coefficients,
but this function assumes that they will be listed with the y-intercept
\emph{A0} in the first row and the rate constant \emph{k} in the next row.
Note that this is for a \emph{mono}exponential decay. If you've fit a bi-
or triexponential decay model to your data, only supply the rate constant
and y intercept for the \emph{terminal} portion of the data.}

\item{extrap_inf_times}{If \code{extrap_inf} is TRUE but you haven't supplied
the coefficients from fitting a monoexponential decay to your data, specify
the time range to use for fitting as \code{c(minTime, maxTime)}. If this is
left as \code{c(NA, NA)}, the time range from tmax to tlast will be used.}

\item{reportFractExtrap}{TRUE or FALSE for whether to report the fraction of
the AUC extrapolated to infinity. If TRUE, this changes the output from a
to a named list that includes the AUC as a number and the fraction
extrapolated as a named item in the list.}

\item{extrap_t0}{TRUE or FALSE for whether to back extrapolate the curve to
0. This is useful when the dose was administered IV and you know you're
missing a significant portion of the curve from t0 to the first sampling
time.}

\item{extrap_t0_coefs}{If you've already performed a nonlinear regression to
a monoexponential, biexponential, or triexponential decay equation,
\code{noncompAUC} will use those for back extrapolation to t0. Provide a
named list of: \describe{\item{\code{coefs}}{the coefficients from a
\code{nls} regression. Format must be the standard output from
\code{summary(nls(...))[["coefficients"]]} or the coefficients from
\code{\link{elimFit}}. It doesn't matter what you name the coefficients,
but this function assumes that they will be listed with the y-intercept for
the first term in the first row, the rate constant for the first term in
the next row, the y intercept for the second term in the next row, the rate
constant for the second term in the next row after that, etc.}
\item{\code{tmax}}{The time to start fitting the elimination curve. This
will be used to determine how far back in time t0 is.} }}

\item{extrap_t0_model}{"monoexponential" or "biexponential". Only used when
\code{extrap_t0} is TRUE and you haven't supplied your own fitted
coefficients. This sets which exponential decay model to fit to your data
and defaults to "monoexponential".}

\item{extrap_t0_times}{If \code{extrap_t0} is TRUE, specify the time range to
use for fitting the exponential decay as \code{c(minTime, maxTime)}. If
this is left as \code{c(NA, NA)}, the full time range from tmax to tlast
will be used.}

\item{reportC0}{TRUE or FALSE for whether to report the back-extrapolated
concentration at t0. If TRUE, the output becomes a named list that includes
the AUC and the extrapolated C0 value. This is useful as a sanity check
because the maximum concentration at t0 in, e.g., plasma should be no
larger than approximately the dose / total plasma volume, which is ~3 L in
a healthy, 70-kg adult.}
}
\value{
Returns the calculated AUC as a number or, depending on the options
  selected, a named list of the AUC (\code{AUC[["AUC"]]}), the fraction of
  the curve extrapolated to infinity (\code{AUC[["Fraction extrapolated to
  infinity"]]}), and the back extrapolated C0 (\code{AUC[["C0"]]}).
}
\description{
Given a data.frame of concentration-time data, \code{noncompAUC} calculates
the area under the concentration-time curve for the times included in the
input data.frame using either the linear or the linear up/log down
trapezoidal rule. Optionally extrapolate to infinity or back extrapolate to
t0.
}
\details{
\strong{A few notes:}\itemize{

  \item If there are two consecutive time points with the same measured
  concentration, that results in an undefined value for the log trapezoidal
  rule. To deal with this, anytime the user has opted for the linear up/log
  down trapezoidal rule but there are also consecutive time points with the
  same concentration, those individual trapezoids will be calculated linearly
  rather than using a log function and all AUCs will be added together at the
  end.

  \item I intentionally omitted the option of using cubic splines for
  calculating the AUC because they can become unstable with noisy
  concentration-time data and are thus less desireable than the trapezoidal
  rule. For more details, please see
  \url{https://www.certara.com/2011/04/02/calculating-auc-linear-and-log-linear/}.}
}
\examples{
data(ConcTime)
IV1 <- ConcTime \%>\% dplyr::filter(SubjectID == 101 & Drug == "A" &
                                        DoseRoute == "IV")
noncompAUC(IV1, time = TimeHr)
noncompAUC(IV1, time = TimeHr, type = "LULD")
noncompAUC(IV1, time = TimeHr, type = "linear")

# Extrapolating to infinity
noncompAUC(IV1, time = TimeHr, extrap_inf = TRUE,
           extrap_inf_times = c(0.5, NA))

# Extrapolating to infinity and reporting the fraction extrapolated
noncompAUC(IV1, time = TimeHr, extrap_inf = TRUE,
           extrap_inf_times = c(0.5, NA),
           reportFractExtrap = TRUE)

# Back extrapolating to t0
noncompAUC(IV1, time = TimeHr, extrap_t0 = TRUE,
           extrap_t0_model = "monoexponential",
           extrap_t0_times = c(0.5, NA))

# Back extrapolating to t0 and reporting extrapolated C0
noncompAUC(IV1, time = TimeHr, extrap_t0 = TRUE,
           extrap_t0_model = "monoexponential",
           extrap_t0_times = c(0.5, NA),
           reportC0 = TRUE)

# Extrapolating to infinity, reporting the fraction extrapolated to infinity,
# back extrapolating to t0, and reporting extrapolated C0
noncompAUC(IV1, time = TimeHr,
           extrap_inf = TRUE,
           extrap_inf_times = c(0.5, NA),
           reportFractExtrap = TRUE,
           extrap_t0 = TRUE,
           extrap_t0_model = "monoexponential",
           extrap_t0_times = c(0.5, NA),
           reportC0 = TRUE)


# For supplying your own coefficients to back extrapolate with:
tmax <- 0.5
# The elimination phase begins at t = 0.5 hrs here, so don't start fitting at
# t0; you'll get bad estimates.
Fit <- nls(Concentration ~ A * exp(-k * (TimeHr - tmax)),
           data = IV1 \%>\%  dplyr::filter(TimeHr >= tmax),
           start = list(A = max(IV1$Concentration), k = 0.01))
MyCoefs <- summary(Fit)[["coefficients"]]

# Extrapolating to infinity with supplied coefficients
noncompAUC(IV1, time = TimeHr, extrap_inf = TRUE,
           extrap_inf_times = c(0.5, NA),
           extrap_inf_coefs = MyCoefs)

# Back extapolating to t0 with supplied coefficients
noncompAUC(IV1, time = TimeHr, extrap_t0 = TRUE,
           extrap_t0_coefs = list(coefs = MyCoefs,
                                  tmax = tmax))

}
